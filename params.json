{"name":"Esl","tagline":"Node.js client and server for FreeSwitch Event Socket","body":"```coffeescript\r\ncall_handler = require('seem') ->\r\n  caller = @data['Channel-Caller-ID-Number']\r\n  callee = @data['Channel-Destination-Number']\r\n  new_caller = yield db.getAsync \"new_caller_for_#{caller}\"\r\n  yield @command 'answer'\r\n  yield @command 'play-file', 'voicemail/vm-hello'\r\n  yield @command 'set', \"effective_caller_id_number=#{new_caller}\"\r\n  yield @command 'bridge', \"sofia/egress/#{callee}@example.net\"\r\n\r\nrequire('esl').server(call_handler).listen(7000)\r\n```\r\n\r\nLoad\r\n====\r\n\r\n    FS = require('esl')\r\n\r\nServer\r\n======\r\n\r\n    FS.server(handler,report).listen(port)\r\n\r\nThe `handler` is required; it is called once for every connection from FreeSwitch (i.e. once for each call). A filter is set up so that the handler only receives events pertaining to the call it handles, and cleanup procedures are automatically called at the end of the connection.\r\n\r\n`report(Error)` is called when the handler fails for any reason. This prevents the server from crashing if the handler crashes. It is optional.\r\n\r\nThe value returned by `FS.server()` is a [net.Server](https://nodejs.org/api/net.html#net_class_net_server), that's why you can (for example) call `.listen()` on it.\r\n\r\nClient\r\n======\r\n\r\n    FS.client(options,handler).connect(port,host)\r\n\r\nThe only option available is `.password`, which defaults to `ClueCon`. The `options` object is optional.\r\n\r\nThe `handler` is required; it is called after authentication with FreeSwitch is successful. Cleanup procedures are automatically called at the end of the connection.\r\n\r\nThe value returned by `FS.client()` is a [net.Socket](https://nodejs.org/api/net.html#net_class_net_socket), that's why you can call `.connect()` on it.\r\n\r\nHandler Context\r\n===============\r\n\r\nThe handler function is called with its context (the `this` object) containing methods and values described in the following sections.\r\n\r\nUsing FreeSwitch commands\r\n=========================\r\n\r\ncommand(app,args) / command_uuid(uuid,app,args)\r\n-------\r\n\r\nSend the application command to FreeSwitch and return a Promise that is only fulfilled once the command completes. For long-running commands such as `bridge` this could be until the call is established.\r\nThe Promise is fulfilled with the header and body of the `CHANNEL_EXECUTE_COMPLETE` event from FreeSwitch.\r\n\r\n    this.command('bridge','sofia/client/6215@example.net')\r\n    .then(function(res){\r\n       var headers = res.headers;\r\n       var body = res.body;\r\n    })\r\n\r\nexecute(app,args) / execute_uuid(uuid,app,args)\r\n-------\r\n\r\nSend the application command to FreeSwitch and return a Promise that is fulfilled immediately with the header and body of the `command/reply` response from FreeSwitch.\r\n\r\n    this.execute('bridge','sofia/client/6215@example.net')\r\n    .then(function(res){\r\n       var headers = res.headers;\r\n       var body = res.body;\r\n    })\r\n\r\n\r\nUsing FreeSwitch API\r\n====================\r\n\r\napi\r\n---\r\n\r\nSends an API command and returns a Promise that fulfills with the body of the response. If a UUID is provided in the response it is available as `.uuid`.\r\n\r\n    this\r\n      .api('originate sofia/client/sip:7002@example.net &bridge(sofia/client/sip:3000@example.net)'\r\n      .then(function(res){\r\n         var originate_uuid = res.uuid;\r\n       })\r\n\r\nbgapi\r\n-----\r\n\r\nSend a background API command and returns immediately a Promise that fulfills with an object containing the UUID of the background job.\r\n\r\n    this\r\n      .bgapi('originate sofia/client/sip:7002@example.net &bridge(sofia/client/sip:3000@example.net)'\r\n      .then(function(res){\r\n         var job_uuid = res.uuid;\r\n       })\r\n\r\nSocket\r\n======\r\n\r\nsocket\r\n------\r\n\r\nThe original socket (client socket or server's call socket).\r\n\r\nend\r\n---\r\n\r\nCloses the socket. A shortcut to `this.socket.end()`.\r\n\r\nEvents\r\n======\r\n\r\non\r\n--\r\n\r\nReceives events from the parser.\r\n\r\n    this.on('DTMF',function(o) {\r\n      var headers = o.headers;\r\n      var body = o.body;\r\n      var dtmf = o.body['DTMF-Digit']\r\n    }\r\n\r\nonce\r\n----\r\n\r\nReturns a Promise that is fulfilled (once) when the event is received.\r\n\r\n    this\r\n      .once('my-event')\r\n      .then(function(data) { ... })\r\n\r\nemit\r\n----\r\n\r\nSends an event that can be caught by `on` or `once`.\r\n\r\n    this.emit('my-event',some_data)\r\n\r\nGeneric\r\n=======\r\n\r\nsendmsg(cmd,args) / sendmsg_uuid(uuid,cmd,args)\r\n-----------------------------------------------\r\n\r\nSend a message (server mode)\r\n\r\n    this.sendmsg(command,args).then(...)\r\n\r\nSend a message (client mode)\r\n\r\n    this.sendmsg_uuid(uuid,command,args).then(...)\r\n\r\nhangup(cause) / hangup_uuid(uuid,cause)\r\n------\r\n\r\nHang-up with the optional `cause`.\r\n\r\nLow-level\r\n=========\r\n\r\nLow-level shortcuts to the corresponding EventSocket commands.\r\n\r\nEvents configuration\r\n---------------------\r\n\r\n    this.event_json(events...)\r\n    this.nixevent()\r\n    this.noevents()\r\n    this.filter(header,value)\r\n    this.filter_delete(header,value)\r\n    this.sendevent(name,args)\r\n\r\n    this.log()\r\n    this.nolog()\r\n\r\nConnection handling\r\n-------------------\r\n\r\nThese are normally called for you, there is no need to use them.\r\n\r\n    this.auth(password)\r\n    this.connect()\r\n    this.linger()\r\n    this.exit()","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}